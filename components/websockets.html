<link rel="import" href="/libraries/polymer/polymer.html">

<polymer-element name="web-socket" attributes="register">
	<script>
	(function() {
		var _handler = null;

		function WebsocketHandler() {
			this.listeners = [];
			this._isConnected = false;
			this._waiting = [];
			this.connect();
		}

		WebsocketHandler.prototype.connect = function() {
			this._socket = new WebSocket("ws://" + window.location.hostname + ":" + window.location.port + "/ws/");
			this._socket.onmessage = this.onMessage.bind(this);
			this._socket.onerror = this.onError.bind(this);
			this._socket.onopen = this.onOpen.bind(this);
			this._socket.onclose = this.onClose.bind(this);
			window.onbeforeunload = this.beforeUnload.bind(this);
		}

		WebsocketHandler.prototype.onMessage = function(msg) {
			console.info("WS: message received", msg.data);
			json = JSON.parse(msg.data);
			for ( var i=0; i < this.listeners.length; i++ ) {
				listener = this.listeners[i];
				if (listener[3] != null) {
					if (json[0] == listener[1] 
						&& json[1][listener[3]] == listener[4]) {
						listener[2](json[0], json[1]);
					}
				} else {
					if (json[0] == listener[1]) {
						listener[2](json[0], json[1]);
					}
				}
			}
		};

		WebsocketHandler.prototype.beforeUnload = function() {
	       	this._socket.onclose = function () {}; // disable onclose handler first
    	    this._socket.close();
		};

		WebsocketHandler.prototype.subscribe = function(comp, name, func, filter_key, filter_id) {
			this.listeners.push([comp, name, func, filter_key, filter_id]);
		};

		WebsocketHandler.prototype.send = function(json) {
			var data = JSON.stringify(json);
			if (this._isConnected) {
				try {
					console.info("WS: sending message " + data);
					this._socket.send(data);
				} catch(error) {
					console.error("cannot send message: error: " + error);
				}
			} else {
					console.info("WS: added on waiting queue: " + data);
				// If not connect add on waiting queue
				this._waiting.push(data);
			}
		};

		WebsocketHandler.prototype.onOpen = function(e) {
			this._isConnected = true;
	    	console.info('WS: Connection open');
			for ( var i=0; i < this.listeners.length; i++ ) {
				this.listeners[i][0].onOpen();
			}
		    // clear waiting queue
		    for (var i = this._waiting.length - 1; i >= 0; i--) {
				console.info("WS: sending waiting message " + this._waiting[i]);
				this._socket.send(this._waiting[i]);
		    }
		}

		WebsocketHandler.prototype.onError = function(error) {
			console.error('There was an un-identified Web Socket error', error);
		}

		WebsocketHandler.prototype.onClose = function(e) {

			this._isConnected = false;
			console.info('WS: Connection closed, reconnecting attempt...');
			for ( var i=0; i < this.listeners.length; i++ ) {
				this.listeners[i][0].onClose();
			}
			window.setTimeout(this.connect.bind(this), 5*1000);
		}

		Polymer("web-socket", {
			ready:function(){
				//window.addEventListener('beforeunload', this.beforeUnload.bind(this));//buggy in chrome
				// Cleanly close websocket when unload window
				if (window.WebSocket) {
					if (_handler == null) {
						_handler = new WebsocketHandler;
					}
				}
			},
			
			send: function(id, json) {
				_handler.send([id, json]);
			},
			register: function(name, func, filter_key, filter_id) {
				_handler.subscribe(this, name, func, filter_key, filter_id);
			},
			onOpen: function() {
				this.fire('websocket-connected');
			},
			onClose: function() {
				this.fire('websocket-closed');
			}
		});
	})();
	</script>
</polymer-element>

